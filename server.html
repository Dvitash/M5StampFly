<!DOCTYPE html>
<meta charset="utf-8" />
<title>Drone Telemetry</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
    --bg: #0b1020;
    --fg: #e6e8ef;
    --mut: #93a1b;
    --card: #121a34;
    --ok: #36c;
    --warn: #c63;
  }
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0;
    font: 14px system-ui;
    background: var(--bg);
    color: var(--fg);
  }
  header {
    padding: 12px 16px;
    border-bottom: 1px solid #1f2a4d;
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
  }
  header h1 {
    font: 600 16px system-ui;
    margin: 0;
  }
  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 12px;
    padding: 12px;
  }
  .card {
    background: var(--card);
    border: 1px solid #1f2a4d;
    border-radius: 10px;
    padding: 12px;
  }
  .row {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
  }
  button {
    background: #1e2b55;
    color: var(--fg);
    border: 1px solid #33457a;
    border-radius: 8px;
    padding: 8px 12px;
    cursor: pointer;
  }
  button:hover {
    filter: brightness(1.1);
  }
  .kv {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 6px 12px;
  }
  .ok {
    color: var(--ok);
  }
  .bad {
    color: var(--warn);
  }
  canvas {
    width: 100%;
    height: 220px;
    border-radius: 8px;
    background: #0d1328;
  }
  .num {
    font: 600 18px;
  }
  .axis {
    opacity: 0.85;
  }
  .kbd {
    background: #0d1328;
    border: 1px solid #23305a;
    border-radius: 6px;
    padding: 2px 6px;
    margin-left: 6px;
  }
  .tiny {
    font-size: 12px;
    opacity: 0.9;
  }
  label {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  input[type="number"] {
    width: 84px;
    background: #0d1328;
    border: 1px solid #23305a;
    color: var(--fg);
    border-radius: 6px;
    padding: 4px 6px;
  }
  .hint {
    opacity: 0.75;
  }
</style>
<header>
  <h1>Drone Telemetry</h1>
  <div id="ip">IP:<span class="kbd" id="host"></span></div>
  <div>RC link: <span id="rc" class="kbd">—</span></div>
  <div>t<sub>us</sub>: <span id="tus" class="kbd">0</span></div>
  <div class="row">
    <button onclick="hover()">Hover 0.5 m</button>
    <button onclick="land()">Land</button>
    <button onclick="buzz(880)">Beep A4</button>
    <button onclick="buzz(0)">Stop Beep</button>
  </div>
</header>

<div class="grid">
  <div class="card">
    <div class="row" style="justify-content: space-between; align-items: baseline">
      <h3 style="margin: 0">Accelerometer (m/s²)</h3>
      <div class="tiny hint">mode: <span id="accMode">high-pass</span> • autoscale</div>
    </div>
    <div class="row tiny">
      <label><input type="checkbox" id="accHp" checked />remove gravity (high-pass)</label>
      <label>cutoff<input type="number" id="accCut" value="0.5" step="0.1" min="0.05" max="5" />Hz</label>
      <label><input type="checkbox" id="accFixed" />fixed range ±</label>
      <input type="number" id="accRange" value="20" step="1" min="2" max="80" />
    </div>
    <div class="row">
      <div>X: <span id="ax" class="num axis">0</span></div>
      <div>Y: <span id="ay" class="num axis">0</span></div>
      <div>Z: <span id="az" class="num axis">0</span></div>
      <div>|a|: <span id="amag" class="num">0</span></div>
      <div class="tiny hint">rms: <span id="arms">0</span></div>
    </div>
    <canvas id="acc"></canvas>
  </div>

  <div class="card">
    <div class="row" style="justify-content: space-between; align-items: baseline">
      <h3 style="margin: 0">Gyroscope (rad/s)</h3>
      <div class="tiny hint">mode: <span id="gyrMode">detrended</span> • autoscale</div>
    </div>
    <div class="row tiny">
      <label><input type="checkbox" id="gyrHp" checked />remove bias drift</label>
      <label>cutoff<input type="number" id="gyrCut" value="0.08" step="0.01" min="0.01" max="1.0" />Hz</label>
      <label><input type="checkbox" id="gyrFixed" />fixed range ±</label>
      <input type="number" id="gyrRange" value="10" step="1" min="1" max="80" />
    </div>
    <div class="row">
      <div>X: <span id="gx" class="num axis">0</span></div>
      <div>Y: <span id="gy" class="num axis">0</span></div>
      <div>Z: <span id="gz" class="num axis">0</span></div>
      <div>|ω|: <span id="gmag" class="num">0</span></div>
      <div class="tiny hint">rms: <span id="grms">0</span></div>
    </div>
    <canvas id="gyr"></canvas>
  </div>

  <div class="card">
    <h3>Keyboard / UI control</h3>
    <div class="row">
      <button onclick="nudge('forward')">↑ Forward</button>
      <button onclick="nudge('backward')">↓ Backward</button>
      <button onclick="nudge('left')">← Left</button>
      <button onclick="nudge('right')">→ Right</button>
    </div>
    <p>stick post demo:</p>
    <div class="row">
      <button onclick="sendStick(0,0,0,0)">Zero sticks</button>
      <button onclick="sendStick(0.3,0,0,0.5)">Cruise</button>
    </div>
    <div class="tiny hint">plot fps: <span id="fps">0</span></div>
  </div>

  <div class="card">
    <h3>Log</h3>
    <input type="text" id="logSearch" placeholder="Search logs..." style="width: 100%; background: #0d1328; border: 1px solid #23305a; color: var(--fg); border-radius: 6px; padding: 6px 8px; margin-bottom: 8px" />
    <pre id="log" style="height: 220px; overflow: auto; margin: 0; background: #0d1328; border: 1px solid #23305a; border-radius: 8px; padding: 8px"></pre>
  </div>

  <div class="card">
    <div class="row" style="justify-content: space-between; align-items: baseline">
      <h3 style="margin: 0">Camera</h3>
      <div class="tiny hint">status: <span id="cameraStatus">disabled</span></div>
    </div>
    <div class="row tiny">
      <label><input type="checkbox" id="cameraEnabled" />enable camera stream</label>
    </div>
    <div id="cameraContainer" style="position: relative; width: 100%; height: 220px; background: #0d1328; border: 1px solid #23305a; border-radius: 8px; overflow: hidden">
      <img id="cameraStream" style="display: none; width: 100%; height: 100%; object-fit: contain" />
      <div id="cameraPlaceholder" style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; color: var(--fg); opacity: 0.7">Camera disabled</div>
    </div>
  </div>

  <div class="card">
    <div class="row" style="justify-content: space-between; align-items: baseline">
      <h3 style="margin: 0">Flight Path (Sensor-Based Position)</h3>
      <div class="tiny hint">pos: <span id="flowPos">0, 0</span> px | delta: <span id="flowDelta">0, 0</span> px</div>
    </div>
    <div class="row tiny">
      <label><input type="checkbox" id="mapReset" />reset on next reading</label>
      <button onclick="resetMap()" style="padding: 4px 8px; font-size: 12px">Reset Map</button>
    </div>
    <canvas id="map"></canvas>
  </div>
</div>

<script>
  // http helpers
  const host = location.host || "192.168.4.1";
  document.getElementById("host").textContent = host || "(set)";
  const http = (p, opt = {}) => fetch(`http://${host}${p}`, opt);

  // control endpoints
  function hover() {
    http(`/hover?altitude=0.5`).catch(() => {});
  }
  function land() {
    http(`/land`).catch(() => {});
  }
  function buzz(freq) {
    if (freq > 0) http(`/buzz/start?freq=${freq}`);
    else http(`/buzz/stop?freq=880`);
  }
  function nudge(direction, speed = 0.6) {
    http(`/move?direction=${direction}&speed=${speed}`).catch(() => {});
  }
  function sendStick(ail, ele, rud, thr) {
    http(`/stick`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ ail, ele, rud, thr }) });
  }

  // arrow key nudges
  const keyMap = { ArrowUp: "forward", ArrowDown: "backward", ArrowLeft: "left", ArrowRight: "right" };
  let repeatTimer = null,
    repeatKey = null;
  document.addEventListener("keydown", (e) => {
    if (!keyMap[e.key] || repeatKey === e.key) return;
    repeatKey = e.key;
    nudge(keyMap[e.key]);
    repeatTimer = setInterval(() => nudge(keyMap[e.key]), 120);
  });
  document.addEventListener("keyup", (e) => {
    if (e.key === repeatKey) {
      clearInterval(repeatTimer);
      repeatTimer = null;
      repeatKey = null;
    }
  });

  // simple ema for mean/variance
  function emaStep(state, x, alpha) {
    const d = x - state.mean;
    state.mean += alpha * d;
    state.var = (1 - alpha) * (state.var + alpha * d * d);
    return state;
  } // one-liner

  // first order high-pass
  function highPassStep(buf, x, dt, cutoffHz) {
    const rc = 1 / (2 * Math.PI * cutoffHz);
    const a = rc / (rc + dt);
    const y = a * (buf.prevY + x - buf.prevX);
    buf.prevX = x;
    buf.prevY = y;
    return y;
  } // one-liner

  // rms tracker
  function rmsStep(state, x, alpha) {
    state = emaStep(state, x, alpha);
    const sigma = Math.sqrt(Math.max(0, state.var));
    return { state, rms: sigma };
  } // one-liner

  // plot with autoscale and zero line
  class Plot {
    constructor(canvas, seriesCount, maxPoints = 600, opts = {}) {
      this.c = canvas;
      this.ctx = canvas.getContext("2d");
      this.series = Array.from({ length: seriesCount }, () => []);
      this.max = maxPoints;
      this.stats = Array.from({ length: seriesCount }, () => ({ mean: 0, var: 0 }));
      this.alpha = 2 / Math.min(maxPoints, 200);
      this.fixed = null;
      this.minRange = opts.minRange ?? 1;
      this.maxRange = opts.maxRange ?? 80;
    } // one-liner
    setFixed(rangeOrNull) {
      this.fixed = rangeOrNull;
    } // one-liner
    push(vals) {
      vals.forEach((v, i) => {
        const s = this.series[i];
        s.push(v);
        if (s.length > this.max) s.shift();
        this.stats[i] = emaStep(this.stats[i], v, this.alpha);
      });
    } // one-liner
    draw() {
      const rect = this.c.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width * devicePixelRatio)),
        h = Math.max(1, Math.floor(rect.height * devicePixelRatio));
      if (this.c.width !== w || this.c.height !== h) {
        this.c.width = w;
        this.c.height = h;
      }
      const ctx = this.ctx;
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      ctx.clearRect(0, 0, rect.width, rect.height);
      let range = this.fixed;
      if (range == null) {
        let r = 0.001;
        for (const st of this.stats) {
          const s = Math.sqrt(Math.max(0, st.var));
          r = Math.max(r, 3 * s);
        }
        range = Math.min(this.maxRange, Math.max(this.minRange, r));
      }
      ctx.strokeStyle = "#23305a";
      ctx.lineWidth = 1;
      for (let y = 0; y <= 4; y++) {
        const yy = y * (rect.height / 4);
        ctx.beginPath();
        ctx.moveTo(0, yy);
        ctx.lineTo(rect.width, yy);
        ctx.stroke();
      }
      const y0 = rect.height - ((0 - -range) / (2 * range)) * rect.height;
      ctx.beginPath();
      ctx.moveTo(0, y0);
      ctx.lineTo(rect.width, y0);
      ctx.stroke();
      const colors = ["#68a0ff", "#8aff8a", "#ff8888", "#ffd166"];
      this.series.forEach((s, si) => {
        if (s.length < 2) return;
        ctx.beginPath();
        ctx.lineWidth = 1.6;
        ctx.strokeStyle = colors[si % colors.length];
        const min = -range,
          max = range;
        const step = rect.width / (this.max - 1);
        s.forEach((v, i) => {
          const x = i * step;
          const y = rect.height - ((v - min) / (max - min)) * rect.height;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      });
    }
  }

  // elements
  const el = (id) => document.getElementById(id);
  const log = (t) => {
    const L = el("log");
    L.textContent = (t + "\n" + L.textContent).slice(0, 4000);
  }; // one-liner

  // plots
  const accPlot = new Plot(el("acc"), 4, 600, { minRange: 1, maxRange: 80 });
  const gyrPlot = new Plot(el("gyr"), 4, 600, { minRange: 0.5, maxRange: 80 });

  // map
  const mapCanvas = el("map");
  const mapCtx = mapCanvas.getContext("2d");
  let mapPath = [];
  let lastAbsoluteX = null;
  let lastAbsoluteY = null;
  let startX = null;
  let startY = null;
  let mapScale = 1.0;
  let mapBounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };

  // threshold for detecting jumps (packet loss or network delay)
  const JUMP_THRESHOLD = 50; // pixels

  function resetMap() {
    mapPath = [];
    lastAbsoluteX = null;
    lastAbsoluteY = null;
    startX = null;
    startY = null;
    mapBounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };
    http(`/reset/position`).catch(() => {});
    drawMap();
  }

  function drawMap() {
    const rect = mapCanvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width * devicePixelRatio));
    const h = Math.max(1, Math.floor(rect.height * devicePixelRatio));
    if (mapCanvas.width !== w || mapCanvas.height !== h) {
      mapCanvas.width = w;
      mapCanvas.height = h;
    }
    const ctx = mapCtx;
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    ctx.clearRect(0, 0, rect.width, rect.height);

    if (mapPath.length === 0) {
      ctx.fillStyle = "#23305a";
      ctx.font = "12px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("Waiting for sensor data...", rect.width / 2, rect.height / 2);
      return;
    }

    // calculate bounds
    let minX = Infinity,
      maxX = -Infinity,
      minY = Infinity,
      maxY = -Infinity;
    for (const p of mapPath) {
      minX = Math.min(minX, p.x);
      maxX = Math.max(maxX, p.x);
      minY = Math.min(minY, p.y);
      maxY = Math.max(maxY, p.y);
    }
    mapBounds = { minX, maxX, minY, maxY };

    // calculate actual movement range
    const rangeX = Math.max(maxX - minX, 0.1); // ensure at least 0.1 to avoid division by zero
    const rangeY = Math.max(maxY - minY, 0.1);

    // add padding: use larger percentage for smaller movements to ensure visibility
    // small movements (< 2 pixels) get 50% padding, larger movements get 10% padding
    const paddingRatioX = rangeX < 2 ? 0.5 : 0.1;
    const paddingRatioY = rangeY < 2 ? 0.5 : 0.1;
    const paddingX = Math.max(rangeX * paddingRatioX, 0.5); // absolute minimum 0.5 pixels
    const paddingY = Math.max(rangeY * paddingRatioY, 0.5);

    // total range with padding
    const totalRangeX = rangeX + paddingX * 2;
    const totalRangeY = rangeY + paddingY * 2;

    // calculate center of actual movement
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;

    // scale to fit with aspect ratio preservation
    const scaleX = rect.width / totalRangeX;
    const scaleY = rect.height / totalRangeY;
    const scale = Math.min(scaleX, scaleY);

    // offset to center the movement
    const offsetX = rect.width / 2 - centerX * scale;
    const offsetY = rect.height / 2 - centerY * scale;

    // draw grid with adaptive spacing based on movement range
    ctx.strokeStyle = "#1f2a4d";
    ctx.lineWidth = 1;

    // adaptive grid spacing: aim for 8-12 grid lines visible
    const targetGridLines = 10;
    const gridSpacingX = totalRangeX / targetGridLines;
    const gridSpacingY = totalRangeY / targetGridLines;

    // round to nice numbers (powers of 10, or 1/2, 1/5 multipliers)
    function niceSpacing(spacing) {
      if (spacing <= 0) return 0.1;
      const order = Math.pow(10, Math.floor(Math.log10(Math.max(spacing, 0.0001))));
      const normalized = spacing / order;
      if (normalized <= 1) return order;
      if (normalized <= 2) return order * 2;
      if (normalized <= 5) return order * 5;
      return order * 10;
    }

    const niceSpacingX = niceSpacing(gridSpacingX);
    const niceSpacingY = niceSpacing(gridSpacingY);

    // grid lines in world coordinates
    const gridStartX = Math.floor((minX - paddingX) / niceSpacingX) * niceSpacingX;
    const gridEndX = Math.ceil((maxX + paddingX) / niceSpacingX) * niceSpacingX;
    const gridStartY = Math.floor((minY - paddingY) / niceSpacingY) * niceSpacingY;
    const gridEndY = Math.ceil((maxY + paddingY) / niceSpacingY) * niceSpacingY;

    for (let gx = gridStartX; gx <= gridEndX; gx += niceSpacingX) {
      const x = gx * scale + offsetX;
      if (x >= 0 && x <= rect.width) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, rect.height);
        ctx.stroke();
      }
    }
    for (let gy = gridStartY; gy <= gridEndY; gy += niceSpacingY) {
      const y = gy * scale + offsetY;
      if (y >= 0 && y <= rect.height) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(rect.width, y);
        ctx.stroke();
      }
    }

    // draw axes (at origin if visible, otherwise at center)
    ctx.strokeStyle = "#33457a";
    ctx.lineWidth = 1.5;
    const zeroX = 0 * scale + offsetX;
    const zeroY = 0 * scale + offsetY;

    // only draw axes if origin is within visible bounds
    if (zeroX >= 0 && zeroX <= rect.width) {
      ctx.beginPath();
      ctx.moveTo(zeroX, 0);
      ctx.lineTo(zeroX, rect.height);
      ctx.stroke();
    }
    if (zeroY >= 0 && zeroY <= rect.height) {
      ctx.beginPath();
      ctx.moveTo(0, zeroY);
      ctx.lineTo(rect.width, zeroY);
      ctx.stroke();
    }

    // draw center lines if origin is not visible
    if (zeroX < 0 || zeroX > rect.width) {
      ctx.strokeStyle = "#23305a";
      ctx.beginPath();
      ctx.moveTo(rect.width / 2, 0);
      ctx.lineTo(rect.width / 2, rect.height);
      ctx.stroke();
    }
    if (zeroY < 0 || zeroY > rect.height) {
      ctx.strokeStyle = "#23305a";
      ctx.beginPath();
      ctx.moveTo(0, rect.height / 2);
      ctx.lineTo(rect.width, rect.height / 2);
      ctx.stroke();
    }

    // draw path with jump detection
    if (mapPath.length > 1) {
      ctx.strokeStyle = "#68a0ff";
      ctx.lineWidth = 2;

      let pathStart = 0;
      for (let i = 1; i < mapPath.length; i++) {
        const prev = mapPath[i - 1];
        const curr = mapPath[i];

        // if this is a jump point, draw previous segment and start new one
        if (curr.jump || prev.jump) {
          if (i > pathStart + 1) {
            ctx.beginPath();
            ctx.moveTo(mapPath[pathStart].x * scale + offsetX, mapPath[pathStart].y * scale + offsetY);
            for (let j = pathStart + 1; j < i; j++) {
              ctx.lineTo(mapPath[j].x * scale + offsetX, mapPath[j].y * scale + offsetY);
            }
            ctx.stroke();
          }

          // draw jump indicator (dashed line or different color)
          if (curr.jump && i > 0) {
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = "#ff8888";
            ctx.lineWidth = 1;
            ctx.moveTo(mapPath[i - 1].x * scale + offsetX, mapPath[i - 1].y * scale + offsetY);
            ctx.lineTo(curr.x * scale + offsetX, curr.y * scale + offsetY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.strokeStyle = "#68a0ff";
            ctx.lineWidth = 2;
          }

          pathStart = i;
        }
      }

      // draw remaining segment
      if (mapPath.length > pathStart + 1) {
        ctx.beginPath();
        ctx.moveTo(mapPath[pathStart].x * scale + offsetX, mapPath[pathStart].y * scale + offsetY);
        for (let i = pathStart + 1; i < mapPath.length; i++) {
          ctx.lineTo(mapPath[i].x * scale + offsetX, mapPath[i].y * scale + offsetY);
        }
        ctx.stroke();
      }
    }

    // draw start point (origin, if visible)
    const originX = 0 * scale + offsetX;
    const originY = 0 * scale + offsetY;
    if (originX >= 0 && originX <= rect.width && originY >= 0 && originY <= rect.height) {
      ctx.fillStyle = "#8aff8a";
      ctx.beginPath();
      ctx.arc(originX, originY, 4, 0, Math.PI * 2);
      ctx.fill();
    }

    // draw current position
    if (mapPath.length > 0) {
      const last = mapPath[mapPath.length - 1];
      const cx = last.x * scale + offsetX;
      const cy = last.y * scale + offsetY;
      ctx.fillStyle = "#ff8888";
      ctx.beginPath();
      ctx.arc(cx, cy, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#ff8888";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(cx, cy, 8, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  // filters and stats
  const accHpBuf = [
    { prevX: 0, prevY: 0 },
    { prevX: 0, prevY: 0 },
    { prevX: 0, prevY: 0 },
  ];
  const gyrHpBuf = [
    { prevX: 0, prevY: 0 },
    { prevX: 0, prevY: 0 },
    { prevX: 0, prevY: 0 },
  ];
  let accRmsState = { mean: 0, var: 0 },
    gyrRmsState = { mean: 0, var: 0 };

  // polling
  let lastDraw = 0,
    lastUs = null,
    lastFpsMark = performance.now(),
    frames = 0;
  async function poll() {
    try {
      const r = await http(`/telemetry`);
      if (!r.ok) throw 0;
      const d = await r.json();

      // time calc
      const now = performance.now();
      let dt = 0.05;
      if (typeof d.t_us === "number") {
        el("tus").textContent = d.t_us;
        if (lastUs != null) {
          dt = Math.max(1e-4, (d.t_us - lastUs) * 1e-6);
        }
        lastUs = d.t_us;
      }

      // rc status
      el("rc").textContent = d.rc_ok ? "OK" : "LOST";
      el("rc").className = d.rc_ok ? "kbd ok" : "kbd bad";

      // use absolute position state from telemetry (true state, not cumulative)
      if (d.flow_pos && Array.isArray(d.flow_pos) && d.flow_pos.length >= 2) {
        const fx = d.flow_pos[0]; // absolute x position
        const fy = d.flow_pos[1]; // absolute y position
        el("flowPos").textContent = `${fx.toFixed(1)}, ${fy.toFixed(1)}`;

        // display delta values
        if (d.flow_delta && Array.isArray(d.flow_delta) && d.flow_delta.length >= 2) {
          const dx = d.flow_delta[0];
          const dy = d.flow_delta[1];
          el("flowDelta").textContent = `${dx.toFixed(2)}, ${dy.toFixed(2)}`;
        } else {
          el("flowDelta").textContent = "—";
        }

        // set start position on first reading or reset
        if (el("mapReset").checked && startX === null) {
          startX = fx;
          startY = fy;
          mapPath = [];
          lastAbsoluteX = null;
          lastAbsoluteY = null;
        } else if (startX === null) {
          startX = fx;
          startY = fy;
          lastAbsoluteX = fx;
          lastAbsoluteY = fy;
        }

        // convert absolute position to relative coordinates for display
        const relX = fx - startX;
        const relY = fy - startY;

        // detect jumps (packet loss or network delay)
        let isJump = false;
        if (lastAbsoluteX !== null && lastAbsoluteY !== null) {
          const dx = Math.abs(fx - lastAbsoluteX);
          const dy = Math.abs(fy - lastAbsoluteY);
          const distance = Math.sqrt(dx * dx + dy * dy);
          isJump = distance > JUMP_THRESHOLD;
        }

        // always add current absolute position to path
        // if there's a jump, we'll mark it so we can draw it differently
        const lastPoint = mapPath.length > 0 ? mapPath[mapPath.length - 1] : null;
        if (!lastPoint || lastPoint.x !== relX || lastPoint.y !== relY || isJump) {
          if (isJump && lastPoint) {
            // add discontinuity marker before the jump
            mapPath.push({ x: lastPoint.x, y: lastPoint.y, jump: true });
          }
          mapPath.push({ x: relX, y: relY, jump: isJump });
          if (mapPath.length > 2000) mapPath.shift();
        }

        // update last known absolute position
        lastAbsoluteX = fx;
        lastAbsoluteY = fy;
      } else {
        // show "no data" if flow_pos not available
        el("flowPos").textContent = "—";
      }

      // always draw map if we have any data (throttled to ~25 fps like plots)
      if ((mapPath.length > 0 || startX !== null) && now - lastDraw > 40) {
        drawMap();
      }

      // raw values
      const axr = d.acc[0],
        ayr = d.acc[1],
        azr = d.acc[2];
      const gxr = d.gyro[0],
        gyr = d.gyro[1],
        gzr = d.gyro[2];

      // filter controls
      const accHpOn = el("accHp").checked;
      const gyrHpOn = el("gyrHp").checked;
      const accCut = Math.max(0.01, Number(el("accCut").value) || 0.5);
      const gyrCut = Math.max(0.01, Number(el("gyrCut").value) || 0.08);
      el("accMode").textContent = accHpOn ? "high-pass" : "raw";
      el("gyrMode").textContent = gyrHpOn ? "detrended" : "raw";

      // apply filters
      const ax = accHpOn ? highPassStep(accHpBuf[0], axr, dt, accCut) : axr;
      const ay = accHpOn ? highPassStep(accHpBuf[1], ayr, dt, accCut) : ayr;
      const az = accHpOn ? highPassStep(accHpBuf[2], azr, dt, accCut) : azr;
      const gx = gyrHpOn ? highPassStep(gyrHpBuf[0], gxr, dt, gyrCut) : gxr;
      const gy = gyrHpOn ? highPassStep(gyrHpBuf[1], gyr, dt, gyrCut) : gyr;
      const gz = gyrHpOn ? highPassStep(gyrHpBuf[2], gzr, dt, gyrCut) : gzr;

      const amag = Math.hypot(ax, ay, az);
      const gmag = Math.hypot(gx, gy, gz);

      // numbers
      el("ax").textContent = ax.toFixed(3);
      el("ay").textContent = ay.toFixed(3);
      el("az").textContent = az.toFixed(3);
      el("gx").textContent = gx.toFixed(3);
      el("gy").textContent = gy.toFixed(3);
      el("gz").textContent = gz.toFixed(3);
      el("amag").textContent = amag.toFixed(3);
      el("gmag").textContent = gmag.toFixed(3);

      // rms readouts
      const accR = rmsStep(accRmsState, amag, 0.05);
      accRmsState = accR.state;
      el("arms").textContent = accR.rms.toFixed(3);
      const gyrR = rmsStep(gyrRmsState, gmag, 0.05);
      gyrRmsState = gyrR.state;
      el("grms").textContent = gyrR.rms.toFixed(3);

      // feed plots
      accPlot.push([ax, ay, az, amag]);
      gyrPlot.push([gx, gy, gz, gmag]);

      // ranges
      accPlot.setFixed(el("accFixed").checked ? Math.max(1, Number(el("accRange").value) || 20) : null);
      gyrPlot.setFixed(el("gyrFixed").checked ? Math.max(0.5, Number(el("gyrRange").value) || 10) : null);

      // draw at ~25 fps
      if (now - lastDraw > 40) {
        accPlot.draw();
        gyrPlot.draw();
        lastDraw = now;
        frames++;
      }

      // fps
      if (now - lastFpsMark >= 1000) {
        el("fps").textContent = frames;
        frames = 0;
        lastFpsMark = now;
      }
    } catch (e) {
      /* best effort polling */
    } finally {
      setTimeout(poll, 50);
    }
  }
  poll();

  // connectivity hint
  http(`/ping`)
    .then((r) => r.text())
    .then((t) => log("ping: " + t))
    .catch(() => log("ping failed"));

  // log polling
  let lastLogId = 0;
  let allLogs = [];
  function renderLogs() {
    const L = el("log");
    const searchTerm = el("logSearch").value.toLowerCase().trim();
    let displayText = "";
    if (searchTerm === "") {
      displayText = allLogs.join("");
    } else {
      allLogs.forEach((line) => {
        if (line.toLowerCase().includes(searchTerm)) {
          displayText += line;
        }
      });
    }
    L.textContent = displayText.slice(0, 4000);
    L.scrollTop = L.scrollHeight;
  }
  async function pollLogs() {
    try {
      const r = await http(`/logs?last_id=${lastLogId}`);
      if (!r.ok) throw 0;
      const d = await r.json();
      if (d.logs && d.logs.length > 0) {
        d.logs.forEach((entry) => {
          const ts = entry.ts / 1000;
          const mins = Math.floor(ts / 60);
          const secs = (ts % 60).toFixed(1);
          const line = `[${mins}:${secs.padStart(4, "0")}] ${entry.msg}\n`;
          allLogs.unshift(line);
          lastLogId = Math.max(lastLogId, entry.id);
          newLogsAdded = true;
        });
        if (allLogs.length > 2000) allLogs = allLogs.slice(0, 2000);
        renderLogs();
      }
    } catch (e) {
      /* best effort */
    }
    setTimeout(pollLogs, (1 / 400) * 1000);
  }
  el("logSearch").addEventListener("input", renderLogs);
  pollLogs();

  // redraw map on resize
  window.addEventListener("resize", () => {
    if (mapPath.length > 0) drawMap();
  });

  // camera streaming
  let cameraStreamActive = false;
  let cameraRetryTimeout = null;
  let cameraEventSource = null;
  const cameraImg = el("cameraStream");
  const cameraContainer = el("cameraContainer");
  const cameraPlaceholder = el("cameraPlaceholder");
  const cameraStatus = el("cameraStatus");
  const cameraEnabled = el("cameraEnabled");

  function updateCameraDisplay() {
    if (cameraEnabled.checked && cameraStreamActive) {
      cameraImg.style.display = "block";
      cameraPlaceholder.style.display = "none";
      cameraStatus.textContent = "streaming";
      cameraStatus.className = "tiny hint ok";
    } else if (cameraEnabled.checked && !cameraStreamActive) {
      cameraImg.style.display = "none";
      cameraPlaceholder.style.display = "block";
      cameraPlaceholder.textContent = "connecting...";
      cameraStatus.textContent = "connecting...";
      cameraStatus.className = "tiny hint";
    } else {
      cameraImg.style.display = "none";
      cameraPlaceholder.style.display = "block";
      cameraPlaceholder.textContent = "Camera disabled";
      cameraStatus.textContent = "disabled";
      cameraStatus.className = "tiny hint";
    }
  }

  function startCameraStream() {
    if (!cameraEnabled.checked || cameraStreamActive) return;

    cameraStreamActive = true;
    updateCameraDisplay();

    // set src to trigger MJPEG stream - browsers handle multipart responses well with img tags
    cameraImg.src = `http://${host}/camera/stream?t=${Date.now()}`;

    // handle stream loading
    cameraImg.onload = () => {
      cameraStreamActive = true;
      updateCameraDisplay();
      log("camera stream started");
    };

    cameraImg.onerror = () => {
      cameraStreamActive = false;
      updateCameraDisplay();
      log("camera stream failed, retrying...");
      // retry after 2 seconds
      cameraRetryTimeout = setTimeout(startCameraStream, 2000);
    };
  }

  function stopCameraStream() {
    cameraStreamActive = false;
    if (cameraRetryTimeout) {
      clearTimeout(cameraRetryTimeout);
      cameraRetryTimeout = null;
    }
    if (cameraImg.src.startsWith("blob:")) {
      URL.revokeObjectURL(cameraImg.src);
    }
    cameraImg.src = "";
    updateCameraDisplay();
    log("camera stream stopped");
  }

  function toggleCamera() {
    if (cameraEnabled.checked) {
      startCameraStream();
    } else {
      stopCameraStream();
    }
  }

  // camera control events
  cameraEnabled.addEventListener("change", toggleCamera);

  // start camera if enabled by default
  if (cameraEnabled.checked) {
    setTimeout(startCameraStream, 1000); // delay to let page load
  }
</script>
